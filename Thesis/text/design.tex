
\chapter{Design and Implementation}
\section{SQUISH-E}
In this section we introduce the SQUISH-E algorithm, present a pseudo-code and analyze its complexity. \\

The SQUISH-E algorithm compresses a trajectory \(T\) by utilizing two parameters, \(\lambda\) and \(\mu\), to strategically minimize the Synchronized Euclidean Distance (SED) error while achieving a specified compression ratio (\(\lambda\)). It operates by compressing \(T\) until further compression would result in an increase in SED error above \(\mu\), with a notable case being SQUISH-E(\(\lambda\)) where setting \(\mu\) to 0 focuses on minimizing SED error to achieve the compression ratio of \(\lambda\). In contrast, SQUISH-E(\(\mu\)) highlights a scenario where \(\lambda\) is set to 1, aiming to maximize the compression ratio without exceeding the SED error threshold defined by \(\mu\). A pivotal aspect of SQUISH-E is its use of a priority queue \(Q\), in which the priority of each point is determined by an upper bound on the SED error that could be introduced by its removal. This mechanism allows SQUISH-E to efficiently identify and remove the point with the lowest priority, i.e., the point whose removal would result in the least increase in SED error, in \(O(\log |Q|)\) time. This process effectively controls the growth of SED error, ensuring the algorithm's efficiency in compressing trajectory data while maintaining the integrity of the spatial information \cite{muckell2014compression}. In order to have a fully online algorithm SQUISH-E(\(\mu\)) is not taken into account and we only take into account SQUISH-E(\(\lambda\)). The error function is the same but in our implementation it could be a nice idea to compare different error function to find the best ones for some situation.

\subsection{Algorithm Pseudo-Code}
In this section we will present the pseudo-code of SQUISH-E algorithm used in our work. \\

\begin{algorithm}[H]
    \DontPrintSemicolon
    \KwIn{trajectory $T$, lower bound $\lambda$ on compression ratio as a percentage value}
    \KwOut{trajectory $T'$}
    $\beta \gets 4$ \tcp*{the initial capacity of $Q$ is 4}
    \ForEach{point $P_i \in T$}{
        \If{$ i * lambda \geq \beta$}{
            $\beta \gets \beta + 1$ \tcp*{increase the capacity of $Q$}
        }
        set\_priority($P_i, \infty, Q$) \tcp*{enqueue $P_i$ with the priority of $P_i$ being $\infty$}
        $\pi[P_i] \gets 0$\;
        \If{$i > 1$}{
            $succ[P_{i-1}] \gets P_i$ \tcp*{register $P_i$ as $P_{i-1}$'s closest successor}
            $pred[P_i] \gets P_{i-1}$ \tcp*{register $P_{i-1}$ as $P_i$'s closest predecessor}
            adjust\_priority($P_{i-1}, Q, pred, succ, \pi$) \tcp*{Algorithm 3}
        }
        \If{$|Q| = \beta$}{
            reduce($Q, pred, succ, \pi$) \tcp*{Algorithm 2}
        }
    }
    \Return{trajectory $T'$ comprising the points in $Q$ in the order reflected in the $succ$ map}
    \caption{SQUISH-E($T, \lambda$)}
    \label{alg:squish_e}
\end{algorithm}

The algorithm in the Listing \ref{alg:squish_e} we can analyze the time complexity. The algorithm works iteratively, receiving each point one by one, which is convenient for our streaming case. Complexity is therefore at least $O(n * max(O(loop) ))$ .The lambda variable has also been modified. Next, the following adjust priority in the Listing \ref{alg:adjust_priority} and in the Listing \ref{alg:reduce} reduce algorithms are presented.


\begin{algorithm}[H]
    \DontPrintSemicolon

    \KwIn{priority queue $Q$, maps $\text{pred}, \text{succ}$ and $\pi$ (refer to Table 2)}
    $P_j \gets \text{remove\_min}(Q); \quad$ // the lowest priority point is removed from $Q$\;

    $\pi[succ[P_j]] \gets \text{max}(priority(P_j) , \pi[succ[P_j]]); \quad$  // update neighbor priority\;
    $\pi[pred[P_j]] \gets \text{max}(priority(P_j) , \pi[pred[P_j]]); \quad$ // update neighbor priority\;


    $succ[\text{pred}[P_j]] \gets succ[P_j]; \quad$ // update neighbor's neighbor of $P_j$ \;
    $\text{pred}[succ[P_j]] \gets \text{pred}[P_j]; \quad$ // update neighbor's neighbor of $P_j$ \;


    $\text{adjust\_priority}(\text{pred}[P_j], \text{pred}, \text{succ}, \pi); \quad$ // Algorithm 3\;
    $\text{adjust\_priority}(succ[P_j], \text{pred}, \text{succ}, \pi); \quad$ // Algorithm 3\;
    remove the entry for $P_j$ from $\text{pred}, \text{succ},$ and $\pi; \quad$ // garbage collection\;

    \caption{reduce($Q, \text{pred}, \text{succ}, \pi$)}
    \label{alg:reduce}
\end{algorithm}



\begin{algorithm}[H]
    \DontPrintSemicolon

    \KwIn{point $P_j$, priority queue $Q$, maps $\text{pred}, \text{succ}$ and $\pi$ (refer to Table 2)}
    \If{$\text{pred}[P_j] \neq \text{null}$ and $\text{succ}[P_j] \neq \text{null}$}{
        $p \gets \pi[\text{SED}(P_j,\text{pred}[P_j], \text{succ}[P_j])];$\;
        $\text{set\_priority}(P_j, p, Q);$\;
    }

    \caption{adjust\_priority($P_j, Q, \text{pred}, \text{succ}, \pi$)}
    \label{alg:adjust_priority}
\end{algorithm}


To achieve the optimum complexity of this algorithm, it is imperative that the most expensive operation in the loop is $O(log(n))$. Next, the focus will be on variables and their methods, in order to determine the required implementation elements.

\subsection{Variables}

In this section, we define and explain the various variables and data structures used in the SQUISH-E algorithm. Understanding these variables is crucial for comprehending how the algorithm operates and manages the compression process.

\begin{table}[h!]
    \centering
    \label{tab:variables}
    \begin{tabular}{ll}
        \hline
        \textbf{Variable} & \textbf{Description} \\
        \hline
        $Q$             & Priority queue that stores points based on their priority. \\
        $p_{\pi}$       & Point with the lowest priority in the priority queue. \\
        $\text{pred}$   & Predecessor map that stores the predecessor of each point. \\
        $\text{succ}$   & Successor map that stores the successor of each point. \\
        $\pi$           & Priority map that stores the priority of each point. \\
        $P_i$           & A specific point in the trajectory or priority queue. \\
        $\text{SED}$    & Synchronized Euclidean Distance function used to calculate error. \\
        \hline
    \end{tabular}
    \caption{Comprehensive list of variables used in the SQUISH-E algorithm.}
\end{table}

\paragraph{Maps}

As mentioned before, we use three maps in the SQUISH-E algorithm: two that maintain point-point relationships and one that maintains point-priority relationships. These maps are essential for tracking the relationships and priorities of points in the trajectory.

\subparagraph{Variables related to the Maps}
The maps used in the algorithm include:

\begin{itemize}
    \item \texttt{$\text{pred}$}: This map stores the predecessor of each point. For a given point $P_i$, 
    $\text{pred}[P_i]$ returns the point that directly precedes $P_i$ in the trajectory.
    \item \texttt{$\text{succ}$}: This map stores the successor of each point. For a given point $P_i$, 
    $\text{succ}[P_i]$ returns the point that directly follows $P_i$ in the trajectory.
    \item \texttt{$\pi$}: This map stores the priority of each point. For a given point $P_i$, $\pi[P_i]$ returns the priority value assigned to $P_i$ based on the Synchronized Euclidean Distance (SED) error that would be introduced by its removal.
\end{itemize}

\subparagraph{Methods for the Maps}
The methods necessary to implement and manipulate these maps are derived from the core operations of the SQUISH-E algorithm, which involves setting and adjusting priorities, and managing predecessor and successor relationships:

\begin{itemize}
    \item \texttt{set(key, value, map)}: This method sets the value for a given key in the map. For example,
    \texttt{set($P_i$, $P_j$,\text{pred})} would set $P_j$ as the predecessor of $P_i$.
    
    \item \texttt{remove(key, map)}: This method removes the key and its corresponding value from the map. For instance, \texttt{remove($P_i$, \text{pred})} would remove the entry for $P_i$ from the predecessor map.
    \item \texttt{get(key, map)} $\rightarrow$ \texttt{value}: This method retrieves the value associated with the given key in the map. For example, \texttt{get($P_i$, \text{succ})} would return the successor of $P_i$.
\end{itemize}

\paragraph{Priority Queue}

Another critical data structure in the SQUISH-E algorithm is the priority queue. The priority queue stores elements as point-priority pairs and maintains a sorted structure so that the point with the lowest priority can be efficiently removed. This structure is essential for the algorithm to function correctly, as it allows for the dynamic adjustment and removal of points based on their impact on the SED error.

\subparagraph{Variables related to the Priority Queue}
The priority queue $Q$ involves the following variables:

\begin{itemize}
    \item \texttt{$Q$}: The priority queue itself, which holds the points and their associated priorities.
    \item \texttt{$p_{\pi}$}: This variable refers to the point with the lowest priority in the priority queue, which is the next candidate for removal.
\end{itemize}

\subparagraph{Methods for the Priority Queue}
The methods required to implement and manipulate the priority queue are derived from the SQUISH-E algorithm's need to set and adjust priorities, and dynamically remove points to control the SED error. These methods include:

\begin{itemize}
    \item \texttt{set\_priority(key, value, Q)}: This function sets the priority of a point in the priority queue. It can be broken down into two sub-methods:
    \begin{itemize}
        \item \texttt{remove(key, Q)} or \texttt{replace(key, Q)}: Depending on the implementation, this method either removes the point with the given key from the priority queue or replaces its priority value.
        \item \texttt{push(key, value, Q)}: This method adds a new point with its priority to the priority queue.
    \end{itemize}
    \item \texttt{remove\_min(Q)}: This method removes and returns the point with the lowest priority from the priority queue. This operation is critical for maintaining the queue's structure and ensuring that the point causing the least increase in SED error is removed.
\end{itemize}

As the \texttt{set\_priority} function is closer to the characteristics of an array than a traditional priority queue, it poses a challenge if existing resources do not allow these methods to be implemented in $O(\log(n))$ time at most. Efficient implementation of these methods is crucial for the algorithm's performance and scalability.



